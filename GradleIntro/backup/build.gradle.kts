/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/6.7.1/userguide/building_java_projects.html
 */
import org.gradle.internal.jvm.Jvm
import org.apache.tools.ant.taskdefs.condition.Os

plugins {
    java
    // Apply the application plugin to add support for building a CLI application in Java.
    application
}

repositories {
    // Use JCenter for resolving dependencies.
    jcenter()
}

dependencies {
    println("DEPENDENCIES ........................... ")
    // Use JUnit test framework.
    testImplementation("junit:junit:4.13")
    implementation("junit:junit:4.13")

    // This dependency is used by the application.
    implementation("com.google.guava:guava:29.0-jre")
}

application {
    // Define the main class for the application.
    mainClass.set("demo.App")
}

/*
ADDED TASKS
 */

tasks.register("notgood"){
    println("Message shown during the configuration phase: no task action defined ${this}")
}

tasks.register("welcome") { //can be declared before hello and count
    dependsOn("hello")
    dependsOn("count")
    doLast {
        println("You are welcome ")
    }
}

tasks.register("hello") {
    doLast {
        println("Hello world from added Task!")
    }
}

tasks.register("count") {
    doLast {
        repeat(4) { print("$it ") }
        println()
    }
}

repeat(4) { counter ->
    tasks.register("task$counter") {
        doLast {
            println("I'm task number $counter")
        }
    }
}

tasks.named("task0") { dependsOn("task3", "task2") }

val t0 = tasks.named("task0")
t0{
    doFirst {
        println("Configured later, but executed as first in task named ${t0.name}")
    }
}
t0{
    doLast {
        println("Another last of task named ${t0.name}")
    }
}

tasks.named("task2") { mustRunAfter(tasks.named("task3")) }
/*
tasks.getByName("task3") { // let's find an existing task
    doFirst { // Similar to doLast, but adds operations in head
        println("Task3: code configured later, but executed as first.")
    }
}

 */

//DOES NOT WORK
//defaultTasks("hello", "myclean")

task("myclean") {
    description = "A task to clean."
    doLast {
        println("My Default Cleaning!")
    }
}


//import org.gradle.internal.jvm.Jvm // Jvm is part of the Gradle API
tasks.register<Exec>("printJavaVersion") { // Do you Recognize this? inline function with reified type!
// Configuration action is of type T.() -> Unit, in this case Exec.T() -> Unit
        val javaExecutable = Jvm.current().javaExecutable.absolutePath
        commandLine( // this is a method of class org.gradle.api.Exec
                javaExecutable, "-version"
        )
// There is no need of doLast / doFirst, actions are already configured
// Still, we may want to do something before or after the task has been executed
    doLast {  println("-------- invocation complete") }
    doFirst { println("-------- Ready to invoke $javaExecutable") }
}

/*
EXPLORE THE FILES
 */
tasks.register("showSrc"){
    //SEE https://docs.gradle.org/current/userguide/working_with_files.html
    //https://docs.gradle.org/current/javadoc/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object...-
    //https://docs.gradle.org/current/javadoc/org/gradle/api/file/FileCollection.html
    fun showDir(prefix: String, dir: File) : Unit  {
        println(prefix + "DIRECTORY:" + dir)
        dir.listFiles()  //Collection of Files
                .forEach { it: File -> if( it.isDirectory ) { showDir(prefix + "   ", it) }
                else println(prefix + "FILE:" + it.name)
                }
    }
    doLast {
        showDir("", file("src"))
    }
}
/*
tasks.withType<JavaCompile> {
    //enable compilation in a separate daemon process
    //options.fork = true
    println( "classpath=...$classpath  sourceCompatibility=$sourceCompatibility" )
}
*/
//https://docs.gradle.org/current/userguide/declaring_dependencies.html
//val separator      = if (Os.isFamily(Os.FAMILY_WINDOWS)) ";" else ":"
//val classpathFiles = compileClasspath.resolve()

//val myclasspath =  configurations["compileClasspath"].resolve()
//println( " .......... classpath=$myclasspath" )

/*
COMPILING FROM SCRATCH
 */
fun findSources(): Array<String> = projectDir // From the project
        .listFiles { it: File -> it.isDirectory && it.name == "src" } // Find a folder named 'src'
        ?.firstOrNull() // If it's not there we're done
        ?.walk() // If it's there, iterate all its content (returns a Sequence<File>)
        ?.filter { it.extension == "java" } // Pick all Java files
        ?.map { it.absolutePath } // Map them to their absolute path
        ?.toList() // Sequences can't get converted to arrays, we must go through lists
        ?.toTypedArray() // Convert to Array<String>
        ?: emptyArray() // Yeah if anything's missing there are no sources

tasks.register<Exec>("mycompileJava") {
    val sources = findSources()
    println("       mycompileJava sources.size=" + sources.size  )
    if (sources.isNotEmpty()) { // If the folder exists and there are files
        val javacExecutable = Jvm.current().javacExecutable.absolutePath // Use the current JVM's javac
        commandLine(
                "$javacExecutable",
                //"-cp", "$myclasspath",
                "-cp", "$projectDir/libs/junit-4.13.jar;$projectDir/build/bin/*", //required to compile AppTest
                "-d", "$buildDir/bin", // destination folder: the output directory of Gradle, inside "bin"
                *sources
        )
    }
// the task's doLast is inherited from Exec
}


/*
CUSTOM TASK TYPES
*/

open class CustomTask @javax.inject.Inject constructor(
        private val message: String,
        private val number: Int
) : DefaultTask()
tasks.register<CustomTask>("myTask", "hello", 42)


open class GreetingTask : DefaultTask() {
    var greeting = "default hello from GreetingTask"

    @TaskAction
    fun greet() {
        println(greeting)
    }
}
// Create a task using the task type
tasks.register<GreetingTask>("greetings")

// Customize the greeting
tasks.register<GreetingTask>("mygreetings") {
    greeting = "my customised greetings from GreetingTask"
}



//------------------------------------------------------------
data class FinderInFolder(val directory: String) {
    fun withExtension(extension: String): Array<String> = projectDir
            .listFiles { it: File -> it.isDirectory && it.name == directory }
            ?.firstOrNull()
            ?.walk()
            ?.filter { it.extension == extension }
            ?.map { it.absolutePath }
            ?.toList()
            ?.toTypedArray()
            ?: emptyArray()
}
fun findFilesIn(directory: String) = FinderInFolder(directory)
fun findSources1() = findFilesIn("src").withExtension("java")
fun findLibraries() = findFilesIn("libs").withExtension("jar")
fun DependencyHandlerScope.forEachLibrary(todo: DependencyHandlerScope.(String) -> Unit) {
    findLibraries().forEach {
        println("forEachLibrary $it"); todo(it)
    }
}

// Create a new configuration, our compileClasspath
val mycompileClasspath: Configuration by configurations.creating

//val classpathFiles = mycompileClasspath.resolve()

//println( " ======mycompileClasspath ===== " + mycompileClasspath.resolve().joinToString(separator = ";") )
println( " ======findSources1 ===== " + findSources1().size )
//findSources1().forEach { println("... ${it}") }
//findLibraries().forEach { println("... ${it}") }

dependencies {
    println( " DEPENDECIES new ............... " )
    forEachLibrary {
        println( " DEPENDENCY ............... $it" )
        mycompileClasspath( files(it) )
    }
}

// Write a task of type Exec that launches javac
tasks.register<Exec>("dpcompileJava") {
    // Resolve the classpath configuration
    // (in general, files could be remote and need fetching)
    val classpathFiles = mycompileClasspath.resolve()
    // Build the command
    val sources = findSources1()
    if (sources.isNotEmpty())  {
        // Use the current JVM's javac
        val javacExecutable = Jvm.current().javacExecutable.absolutePath
        val separator = if (Os.isFamily(Os.FAMILY_WINDOWS)) ";" else ":"
        commandLine(
                "$javacExecutable",
                "-cp", classpathFiles.joinToString(separator = separator),
                "-d", "$buildDir/bin",
                *sources
        )
    }
    // the task's doLast is inherited from Exec
}


//-------------------------------------------------------------
tasks.register("buildDirClean") { // A generic task is fine
    if (!buildDir.deleteRecursively()) {
        throw IllegalStateException("Cannot delete $buildDir")
    }
}

