<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;

}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;

}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 700px;
    font-size: 15px;
}
k{
    color: #990000;
	font-weight: bold;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #C0F0E0;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
   
<title>GradleIntro</title></head>
    
<body>
<div id="top">
<h1>ISS_2021 |  Introduction to Gradle<font size="5"></font> </h1>
<a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2021Lab/blob/master/it.unibo.issLabStart/userDocs/LectureCesena2021.html" target="isslm">LabISS-lectures site</a></font> 
</div>  


<div class="body"> 
<h2>Introduction</h2>

 For an introduction, from the <a href="https://docs.gradle.org/current/userguide/userguide.html" target="web">Gradle User Manual</a>,
 
 read <a href="https://docs.gradle.org/current/userguide/what_is_gradle.html" target="web">What is Gradle?</a>
and 
<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#build_lifecycle" target="web">Build Lifecycle</a>.


	<h3>Gradle | Basic concepts</h3>
	<ul>
	<li>Created in 2008 by Gradleware, <a href="https://docs.gradle.org/current/userguide/userguide.html" target="web">Gradle</a> 
	is mostly implemented in Java 5, with an outer layer in Groovy or Kotlin.
<div class="remark">
In our work, we will write <i>Gradle configuration scripts</i> in Kotlin DSL as described in 
<a href="https://docs.gradle.org/current/dsl/index.html" target="web">Gradle Build Language Reference</a>
</div>	


	</li>
	<li><k>Gradle project</k>: the semantics is up to us (e.g. build a library JAR, a web application ...).
	A project does not necessarily represent a <i>thing to be built</i>. It might represent a  <k>thing to be done</k>, 
		such as deploying your application to staging or production environments. 
		Each project is made up of one or more <ks>tasks</ks>.</li>
	<li><k>Gradle <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="web">Task</a></k>: 
	atomic piece of work (e.g. compiling some classes, creating a JAR,...) which a build performs. </li>
	<li><k>Gradle build script</k>:  Gradle executes  as a set of 'declarative' sentences written as a Groovy (<ks>build.gradle</ks>) or Kotlin 
	(<ks>build.gradle.kts</ks>) script. 
	These languages promote the creation of <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="web">Domain-specific language (DSL)</a>.
	
</li>
	<li><k>Gradle plugin</k>: Gradle at its core intentionally provides very little for real world
automation. All of the useful features, are added by plugins (written in Groovy), that provide concepts, configuration blocks, and tasks  reusable across projects.
	</li>
	<li><k>Gradle Java plugin</k>: introduces the concept of source set, with an associated compile classpath
and runtime classpath, with defaults that copy the Maven conventions:
		<ul>
		<li>main containing <ks>src/main/java</ks>  and <ks>src/main/resources</ks> </li>
		<li>test containing <ks>src/test/java</ks>  and <ks>src/test/resources</ks> </li>
		</ul>
	</li>
	<li><k>Gradle <a href="https://docs.gradle.org/current/userguide/gradle_wrapper.html" target="web">wrapper</a></k>: 
		a script that invokes a declared version of Gradle, downloading it beforehand if necessary.
	
		<ul>
 		<li><tt>gradle/wrapper/gradle-wrapper.properties</tt>, stores the information about the Gradle distribution.</li>
		<li><ks>gradle wrapper --gradle-version 2.11</ks> downloads <tt>version 2.11</tt>. </li>
		<li><ks>./gradlew <task></ks> runs <tt><task></tt> with that exact version.</li>
 
		</ul>
		<div class="remark">
		The Gradle wrapper is the correct way to use gradle.
		</div>
	</li>

<li>
Gradle evaluates and executes build scripts in three phases (that form Gradle’s Build Lifecycle): 
<k>Initialization, Configuration, Execution</k>.<br/> 
A build essentially configures a set of tasks and wires them together — based on their dependencies — to create a Directed acyclic graph (DAG) of thasks. 

 <center><img src="./img/gradleBuild.png" alt="gradleBuild.png" width="80%" height="80%"></center>

Once the task graph has been created, Gradle determines which tasks need to be run in which order and then proceeds to execute them.
<br/>
Delaying the actual execution allows for a more fine grained configuration. This will be especially useful when modifying existing behavior 
<div class="remark">
Well-designed build scripts describe <k>what</k> steps are needed to build the software, 
not <k>how</k> those steps should do the work. That’s a job for custom task types and plugins.
</div>
</li> 
<li>Gradle provides several mechanisms that allow you to extend it: 
<ul>
<li><a href="https://docs.gradle.org/current/userguide/custom_tasks.html" target="web">Custom task types</a>
(It’s typically best to put the source file for a custom task type in the 
<a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="web">buildSrc</a> directory)</li>
<li>Custom task actions</li>
<li>Extra properties</li>
</ul>


</li>

<li>
When Gradle executes a Kotlin build script (<ks>.gradle.kts</ks>), it compiles the script into a subclass of 
<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/-kotlin-build-script/index.html" target="web">KotlinBuildScript</a>.
This means that all of the visible properties and functions declared by the KotlinBuildScript type are available in your script.

<!-- See also <a href="https://docs.gradle.org/current/userguide/kotlin_dsl.html#sec:kotlin" target="web">Kotlin DSL</a> -->

See <a href="https://docs.gradle.org/current/userguide/writing_build_scripts.html" target="web">Writing Build Scripts</a> 


Each build script you have is associated with an object of type Project and as the build script executes, it configures this Project.
</li>

<li>

and <a href="https://docs.gradle.org/current/userguide/application_plugin.html" target="web">The Java Application Plugin</a> that
shows the following diagram for the 
<a href="https://docs.gradle.org/current/userguide/java_plugin.html#lifecycle_tasks" target="web">Java Plugin Lifecycle Tasks</a>:

<center><img src="./img/javaPluginTasks.png" alt="javaPluginTasks.png" width="100%" height="100%"></center>

 
</li>

<li>Gradle uses two main directories to perform and manage its work: the Gradle <ks>user home</ks> directory 
and the <ks>Project root</ks> directory.
See <a href="https://docs.gradle.org/current/userguide/directory_layout.html" target="web">The Directories and Files Gradle Uses</a>
<li>
</ol>

<h1>Hands on Gradle</h1>
<h2>Starting</h2>
From <a href="https://docs.gradle.org/current/samples/sample_building_java_applications.html" target="web">Building Java Applications Sample</a>.<br/><br/>
<ol>
<li>
Start with some automatic code generation:
<pre>
<k>gradle init</k> (select 2, 3, 1, 2, 1, demo, demo)

├── gradle 
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew 	<kc>//Generable with the built-in command</kc> <k>gradle wrapper --gradle-version=&lt;VERSION></k>
├── gradlew.bat 
├── settings.gradle.kts 	<kc>//lists the subprojects</kc>
└── app
    ├── build.gradle.kts 	<kc>//the build configuration script</kc>
    └── src
        ├── main
        │   └── java 
        │       └── demo
        │           └── App.java
        └── test
            └── java 
                └── demo
                    └── AppTest.java
					


</pre>

</li>

<li>Loook at the generated files <a href="../settings.gradle.kts" target="web">settings.gradle.kts</a>.<br/><br/>
By default, Gradle uses the directory name as project name. 
You can change this by creating a settings.gradle file in the directory which specifies the project name.

<pre>
gradle project 	<kc>//get information about your project</kc>

Root project 'demo'
\--- Project ':app'
</pre>
Our build contains one subproject called <ks>app</ks> that represents the Java application we are building. 
It is configured in the <a href="../app/build.gradle.kts" target="web">build.gradle.kts</a> file.
<div class="remark">
One of the purposes of the <a href="../settings.gradle.kts" target="web">settings</a> object is to allow you 
to declare a <k>list of projects</k> which are to be included in the build. <br/>
Each subproject has its own <tt>build.gradle.kts</tt> file. See the section <a href="#multiprojects">Multi projects</a>.
</div>

</li>
<li>
The <ks>Gradle wrapper</ks> is the correct way to use gradle.
<pre>
<k>gradlew run</k> 
SETTINGS RUNS ...

> Configure project :app
 ...... build in app

> Task :app:run
Hello World!

<kc>BUILD SUCCESSFUL</kc> in 7s
2 actionable tasks: 2 executed 
</pre>
</li>
<li>
The <ks>application plugin</ks> bundles the application, with all its dependencies.
<pre>
<k>gradlew build</k> 	 
SETTINGS RUNS ...

> Configure project :app
 ...... build in app

BUILD SUCCESSFUL in 9s
7 actionable tasks: 6 executed, 1 up-to-date
</pre>
Look at the generated directory <a href="../app/build/" target="web">app/build/</a>
 
</li>

<li>
<pre>
<k>gradlew -q build</k> 	<kc>//-q suppresses Gradle’s log messages</kc>
SETTINGS RUNS ...
 ...... build in app
</pre>

</li>
 
</ol>
As the script executes, it configures an object called the <ks>delegate object</ks> of the script:
<ul>
<li><i>Settings</i>  script: delegates to instance of 
<a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html" target="web">Settings</a>
</li>  
<li><i>Init</i>  script: delegates to instance of 
<a href="https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html" target="web">Gradle</a>
</li>
<li><i>Build</i> script: delegates to instance of 
<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="web">Project</a>
</li>
</ul>


<h2>About build, project, <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="web">Tasks</a></h2>
From <a href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html" target="web">Build Script Basics</a>:<br/><br/>
<ol>

<li><h3>Tasks as operations</h3>
A Task is an atomic operation on the project, which can have input and output files,
depend on other tasks (can be executed only if those are completed).

<br/><br/>
Example: add a task in <a href="../app/build.gradle.kts" target="web">build.gradle.kts</a>
and execute it.

<pre>
tasks.register("hello") { <kc>//Inline function with reified type!</kc>
    doLast {	<kc>//a shortcut to define an action</kc>
         println("Hello world from app - this=${this}")
    }
}

<k>gradlew hello</k>
SETTINGS RUNS ...

> Configure project :app
 ...... build in app

> Task :app:hello
Hello world from app - this=task ':app:hello'

BUILD SUCCESSFUL in 6s
1 actionable task: 1 executed

<k>gradlew -q hello</k>	<kc>//<k>-q</k> suppresses Gradle’s log messages</kc>
SETTINGS RUNS ...
 ...... build in app
Hello world from app - this=task ':app:hello'


<k>gradlew -q :app:hello</k>	<kc>//Another way to call</kc>

</pre>


From <a href="https://docs.gradle.org/current/dsl/index.html" target="web">Gradle Build Language Reference</a> we read:
<div class="remark">
A build script is made up of zero or more statements and  script blocks. <br/>
<ul>
<li><ks>Statements</ks> can include method calls, property assignments, and local variable definitions. </li>
<li>A <ks>script block</ks> is a method call which takes a <ks>closure</ks> as a parameter. 
<!-- The closure is treated as a <i>configuration closure</i> which configures some delegate object as it executes. -->
</li>
</ul>
</div>

In particular:
		<ul>
		<li>Every task has a list of <k>actions</k>, and when it executes it runs all of them in the order they are declared.	</li>
		<li>The default task has only actions <tt>doFirst</tt> and <tt>doLast</tt>.</li>
		<li>Tasks can declare dependencies among each other: one task may need other tasks to complete successfully.</li>
		<li>The less dependencies are declared, the faster is the build (due to parallelization).</li>
		<li>Transitive dependencies are resolved automatically (if available in the repository <k>Maven Central / JCenter</k>).</li>
		</ul>
</li>

<!--
<li><h3>TaskContainer</h3>

From <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskContainer.html" target="web">Interface TaskContainer</a>
we gain knowledge about <tt>register</tt>:
<pre>
TaskProvider&lt;Task> register​(String name, Action&lt;? super Task> configurationAction)
</pre>
<ul>
<li>A TaskContainer is responsible for managing a set of Task instances.</li>
<li>You can obtain a <tt>TaskContainer</tt> instance by calling <ks>Project.getTasks()</ks>, 
or using the tasks property in your build script.</li>
</ul>
</li>
-->

<li><h3>Task configuration vs. task execution</h3>
<div class="remark">
The build script executes when Gradle is invoked; it <k>configures</k> tasks and
dependencies.<br/>
A task is actually <k>executed later</k>,  when it is invoked.
</div>

<pre>
tasks.register("notgood"){
    println("Message shown during the configuration phase: no task action defined ")
}

<k>gradlew -q notgood</k>	
SETTINGS RUNS ...
 ...... build in app
Message shown during the configuration phase: no task action defined in task ':app:notgood'
</pre>
</li>




<li><h3>Gradle’s tasks embeds code.</h3>
<div class="remark">
Gradle’s <ks>build scripts are code</ks>: they give you the full power of Groovy and Kotlin.
</div>
<br/>
Example: add in <a href="../app/build.gradle.kts" target="web">build.gradle.kts</a>
<pre>
tasks.register("count") {
    doLast {
        repeat(4) { print("$it ") }
        println()
    }
}

<k>gradlew -q count</k>
SETTINGS RUNS ...
 ...... build in app
0 1 2 3
</pre>

</li>



<li>
You can declare tasks that <ks>depend on other tasks</ks>.
Example: add in <a href="../app/build.gradle.kts" target="web">build.gradle.kts</a>
<pre>
tasks.register("welcome") {	<kc>//could be declared <k>before</k> <tt>hello</tt> and <tt>count</tt></kc>
    dependsOn("hello")
    dependsOn("count")
    doLast {
        println("Welcome task that depends on tasks hello and count ")
    }
}

<k>gradlew -q welcome</k> 
SETTINGS RUNS ...
 ...... build in app
0 1 2 3
Hello world from app - this=task ':app:hello'
Welcome task that depends on tasks hello and count
</pre>

</li>

<li>You can <ks>create tasks dynamically</ks>.

<pre>
repeat(4) { counter ->
    tasks.register("task$counter") {
        doLast {
            println("I'm task number $counter")
        }
    }
}

<k>gradlew -q task1</k>
SETTINGS RUNS ...
 ...... build in app
I'm task number 1
</pre>
</li>

</ol>

<h2 id="multiprojects">Multi projects</h2>
One of the purposes of the <a href="../settings.gradle.kts" target="web">settings</a> object is to allow you 
to declare all the projects which are to be included in the build. See
<a href="https://docs.gradle.org/current/userguide/multi_project_builds.html" target="web">Multi-Project Builds in Gradle</a>

<br/><br/>

In the following, we will create subprojects to introduce further examples of 'gradle programming'.
For example

<pre>
println("SETTINGS RUNS ...")

rootProject.name = "demo"   <kc>//overrides the default behavior of naming </kc>
include("app") <kc>//defines that the build consists of one subproject called app </kc>
include("exampleCompile") <kc>//defines a subproject called exampleCompile </kc>

<k>gradle project</k>
Root project 'demo'
+--- Project ':app'
\--- Project ':exampleCompile'

</pre>

<h2 id="">Examples of Gradle 'programs'</h2>


<ol>



<li>You can <ks>access/modify created tasks</ks> via API.

<pre>
tasks.named("task0") { 	<kc>//Accessing a task via API - adding a dependency</kc>
	dependsOn("task3", "task2") }

<k>gradlew -q task0</k>
I'm task number 2
I'm task number 3
I'm task number 0
</pre>
</li>

<li>
Delaying the actual execution is especially useful when <ks>modifying existing behavior</ks>.</li>

<pre>
val t0 = tasks.named("task0")

t0{	<kc>//Accessing a task via API - adding behaviour</kc>
    doFirst {
        println("Configured later, but executed as first in task named ${t0.name}")
    }
}
t0{ <kc>//Accessing a task via API - adding behaviour</kc>
    doLast {
        println("Another last of task named ${t0.name}")
    }
}

<k>gradlew -q task0</k>
I'm task number 2
I'm task number 3
Configured later, but executed as first in task named task0
I'm task number 0
Another last of task named task0
</pre>


</li>

<li>In some cases it is useful to <ks>control the order</ks> in which 2 tasks will execute, without introducing an explicit dependency between those tasks.
<br/>
There are two ordering rules available: <k>must run after</k> and <k>should run after</k>.
See <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:ordering_tasks" target="web">Ordering tasks</a>


<pre>
tasks.named("task2") { mustRunAfter(tasks.named("task3")) }

<k>gradlew -q task0</k>
I'm task number 3
I'm task number 2
Configured later, but executed as first in task named task0
I'm task number 0
Another last of task named task0
</pre>
</li>
<!--
<li>Gradle allows you to define one or more <ks>default tasks</ks> that are executed if no other tasks are specified. 

<pre>
defaultTasks( "hello" )		//Delegates to Project.defaultTasks()

<k>gradlew -q </k>
</pre>
</li>
-->


</ol>

<h2>Custom task types</h2>
Gradle supports two types of task. One such type is the simple task, where you define the task with an <ks>action closure</ks>,
as done so far. 
<br/>
The other type of task is the enhanced task, where the <ks>behaviour is built into the task</ks>, 
and the task provides some properties which you can use to configure the behaviour.<br/><br/>
See <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html#more_about_tasks" target="web">Authoring Tasks</a>
and
<a href="https://docs.gradle.org/current/userguide/custom_tasks.html#custom_tasks" target="web">Developing Custom Gradle Task Types</a>
<br/><br/>
<ol>
<li>
The Task <a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html" target="web"><ks>org.gradle.api.Exec</ks></a> 
reproted in the <a href="https://docs.gradle.org/current/dsl/index.html" target="web"><ks>Gradle Build Language Reference </ks></a>  
executes a command line process.
<pre>
tasks.register&lt;Exec>("printJavaVersion") { <kc>//Inline function with reified type!</kc>
<kc>// Configuration action is of type T.() -> Unit, in this case Exec.T() -> Unit</kc>
   val javaExecutable = org.gradle.internal.jvm.Jvm.current().javaExecutable.absolutePath
   commandLine( <kc>//this is a method of class org.gradle.api.Exec</kc>
	javaExecutable, "-version"
 )
<kc>// There is no need of <k>doLast / doFirst</k>, actions are already configured
// Still, we may want to do something before or after the task has been executed</kc>
  doLast {  println("-------- invocation complete") }
  doFirst { println("-------- Ready to invoke $javaExecutable") }
}

<k>gradlew -q printJavaVersion</k>
-------- Ready to invoke C:\Program Files\Java\jdk-11.0.8\bin\java.exe
java version "11.0.8" 2020-07-14 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.8+10-LTS)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.8+10-LTS, mixed mode)
-------- invocation complete
</pre>
</li>

<li>
<h3>Example: COMPILING FROM SCRATCH</h3>
<pre>
fun findSources(): Array<String> = projectDir  
        .listFiles { it: File -> it.isDirectory && it.name == "src" }  
        ?.firstOrNull() <kc>// If it's not there we're done</kc>
        ?.walk() <kc>// If it's there, iterate all its content (returns Sequence&lt;File>)</kc>
        ?.filter { it.extension == "java" } <kc>// Pick all Java files</kc>
        ?.map { it.absolutePath } <kc>// Map them to their absolute path</kc>
        ?.toList() <kc>// Sequences can't get converted to arrays, we must go through lists</kc>
        ?.toTypedArray() <kc>// Convert to Array&lt;String></kc>
        ?: emptyArray() <kc>// Yeah if anything's missing there are no sources</kc>

tasks.register<Exec>("mycompileJava") {
    val sources = findSources()
    println("       mycompileJava sources.size=" + sources.size  )
    if (sources.isNotEmpty()) { <kc>// If the folder exists and there are files</kc>
        val javacExecutable = Jvm.current().javacExecutable.absolutePath  
        commandLine(
                "$javacExecutable",
                <kc>//-cp is required to compile AppTest</kc>
                "-cp","$projectDir/libs/junit-4.13.jar;$projectDir/build/bin/*", 
                "-d", "$buildDir/bin", <kc>//destination folder</kc>
                *sources
        )
    }
<kc>// the task's <k>doLast</k> is inherited from Exec</kc>
}
</pre>
<!--

classpath=[C:\Users\anatali\.gradle\caches\modules-2\files-2.1\junit\junit\4.13\e49ccba652b735c93bd6e6f59760d8254cf597dd\junit-4.13.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\com.google.guava\guava\29.0-jre\801142b4c3d0f0770dd29abea50906cacfddd447\guava-29.0-jre.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\org.hamcrest\hamcrest-core\1.3\42a25dc3219429f0e5d060061f71acb49bf010a0\hamcrest-core-1.3.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\com.google.guava\failureaccess\1.0.1\1dcf1de382a0bf95a3d8b0849546c88bac1292c9\failureaccess-1.0.1.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\com.google.guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\b421526c5f297295adef1c886e5246c39d4ac629\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\com.google.code.findbugs\jsr305\3.0.2\25ea2e8b0c338a877313bd4672d3fe056ea78f0d\jsr305-3.0.2.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\org.checkerframework\checker-qual\2.11.1\8c43bf8f99b841d23aadda6044329dad9b63c185\checker-qual-2.11.1.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\com.google.errorprone\error_prone_annotations\2.3.4\dac170e4594de319655ffb62f41cbd6dbb5e601e\error_prone_annotations-2.3.4.jar, C:\Users\anatali\.gradle\caches\modules-2\files-2.1\com.google.j2objc\j2objc-annotations\1.3\ba035118bc8bac37d7eff77700720999acd9986d\j2objc-annotations-1.3.jar]

javac -cp app\build\classes\java\main\demo\  .\app\src\test\java\demo\AppTest.java
javac -cp .\app\junit-4.13.jar;.\app\build\bin\demo\*.class .\app\src\test\java\demo\AppTest.java
javac -cp .\app\junit-4.13.jar;.\app\build\libs\app.jar .\app\src\test\java\demo\AppTest.java
https://docs.gradle.org/current/userguide/building_java_projects.html
https://github.com/gradle/kotlin-dsl-samples/tree/master/samples
-->
</li>

<li><h3>CUSTOM TASKS</h3>

Any open class implementing <a href="https://docs.gradle.org/current/dsl/index.html" target="web"><ks>org.gradle.api.Task</ks></a> can be instanced.
<br/>
See <a href="https://docs.gradle.org/current/userguide/custom_tasks.html" target="web">Developing Custom Gradle Task Types</a>
<pre>
open class GreetingTask : DefaultTask() {
	var greeting = "default hello from GreetingTask"
	
    @TaskAction
    fun greet() {
         println(greeting)
    }
}
<kc>// Create a task using the task type</kc>
tasks.register&lt;GreetingTask>("greetings")

<k>gradlew -q greetings</k>
default hello from GreetingTask

<kc>// Customize</kc>
tasks.register&lt;GreetingTask>("mygreetings"){
	greeting = "my customised greetings from GreetingTask"
}

<k>gradlew -q mygreetings</k>
my customised greetings from GreetingTask
</pre>
</li>




</ol>
You can create a separate project for your task class. 
This project produces and publishes a JAR which you can then use in multiple builds and share with others. 
Generally, this JAR might include some custom plugins, or bundle several related task classes into a single library. 
Or some combination of the two.

<br/><br/>
</div>
 </li>
</ol>
<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:center;font-size:small;color:white">
By AN Unibo-DISI  
</div> 
</body>
</html>